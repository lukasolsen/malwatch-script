#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import json
import requests
import hashlib
import glob
from clib.malwatch.common.constants import MALWATCH_ROOT
from clib.malwatch.local_settings import ROOT_DESTINATION
import magic
from modules.utilities import createFolder, isRunningInLinux, isRunningInWindows
import subprocess
import json


try:
    import pefile
    import peutils
    import mmap
except ImportError:
    print ('pefile not installed, see http://code.google.com/p/pefile/')
    exit()

try:
    from lib.cuckoo.common.abstracts import Processing
    from lib.cuckoo.common.constants import CUCKOO_ROOT
    from lib.cuckoo.common.objects import File
    from lib.cuckoo.common.utils import convert_to_printable
except ImportError:
    print("Cuckoo is not installed, see http://cuckoo.readthedocs.io/en/latest/installation/")


import sys
import fnmatch
#import pyimpfuzzy

try:
    import re2 as re
except:
    import re

#from py2neo import Graph
#from pylouvain import PyLouvain
#from apiscout.ApiScout import ApiScout

statement_c = """
    MERGE (m:Malware{ id:{id} })"""

class Pefile():
    def __init__(self, filepath):
        self.filepath = filepath
        #fd = open(self.filepath, 'rb')
        #pe_data = mmap.mmap(fd.fileno(), 0, access=mmap.ACCESS_READ)
        self.pe = pefile.PE(self.filepath)
        self.pe.full_load()
        self.keys = []
        for keys in self.pe.DOS_HEADER.__keys__:
            for field in keys:
                self.keys.append(field)

        self.number_rva_sizes = self.pe.OPTIONAL_HEADER.NumberOfRvaAndSizes
        self.data_directories = []
        for data_directory in self.pe.OPTIONAL_HEADER.DATA_DIRECTORY:
            self.data_directories.append(data_directory)
        
        self.imported_dlls = []
        for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
            self.imported_dlls.append(entry.dll.decode('utf-8'))

        self.sectionsName = []
        self.sectionsVirtualAddr = []
        self.sectionsVirtualSize = []
        self.sectionsRawSize = []
        for section in self.pe.sections:
            self.sectionsName.append(section.Name.decode('utf-8'))
            self.sectionsVirtualAddr.append(str(hex(section.VirtualAddress)))
            self.sectionsVirtualSize.append(str(hex(section.Misc_VirtualSize)))
            self.sectionsRawSize.append(str(hex(section.SizeOfRawData)))
        
    def toJSON(string):
        return json.dumps(string,
            sort_keys=True, indent=4)
        

    def _create_pe_files(self):
        """Gets PE Info and creates files.
        @return: result of PEfile scan in file.
        """
        if not self.pe:
            return None

        createFolder(ROOT_DESTINATION, "PEFile-Reports")
        f = open(MALWATCH_ROOT + "/submissions/" + "PEFile-Reports/pefile.json", 'w+')

        x = {
            "keys": list(self.keys),
            "number_of_rva_sizes": self.number_rva_sizes,
            "data_directories": str(self.data_directories),
            "imported_dlls": str(self.imported_dlls),
            "sectionsName": str(self.sectionsName),
            "sectionsVirtualAddr": str(self.sectionsVirtualAddr),
            "sectionsVirtualSize": str(self.sectionsVirtualSize),
            "sectionsRawSize": str(self.sectionsRawSize), 
        }
        f.write(str(json.dumps(x, indent=2)))

        f.close()
        




        f = open(MALWATCH_ROOT + "/submissions/" + "PEFile-Reports/pefile.txt", 'w+')
        f.write(str(self.pe))
        f.close()

        try:
            return str(json.dumps(x, indent=2))
        except:
            raise TypeError(json.dumps(x, indent=2))
            

        return str(json.dumps(x, indent=2))
    def check_file(self, f):
        if magic.from_file(f).find("PE32") == -1:
            return False
        if magic.from_file(f).find('self-extracting') != -1:
            return False
        try:
            pe = pefile.PE(f)
            #print(pe)
            matches = self.signatures.match_all(pe, ep_only = True)
            if matches:
                return False
            return True
        except:
            return False
    
    def _get_peid_signatures(self):
        """Gets PEID Signatures.
        @return: matched signatures or None.
        """
        if not self.pe:
            return None
        
        try:
            sig_path = os.path.join(CUCKOO_ROOT, "data",
            "signatures", "MalScan.TXT")
            signatures = peutils.SignatureDatabase(sig_path)
            return signatures.match(self.pe, ep_only=True)
        except:
            return None

    def _get_imported_symbols(self):
        """Gets imported symbols.
        @return: imported symbols dict or None.
        """

        if not self.pe:
            return None
        
        imports = []

        if hasattr(self.pe, "DIRECTORY_ENTRY_IMPORT"):
            for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
                try:
                    symbols = []
                    for imported_symbol in entry.imports:
                        symbol = {}
                        symbol["address"] = hex(imported_symbol.address)
                        symbol["name"] = imported_symbol.name
                        symbols.append(symbol)
                    
                    imports_section = {}
                    imports_section["dll"] = convert_to_printable(entry.dll)
                    imports_section["imports"] = symbols
                    imports.append(imports_section)
                except:
                    print("Could'nt find any imports.")
                    continue
        return imports
    

class Api():
    """Stores and analyze malwares info in neo4j"""

    def __init__(self, host, port, user, password, threshold=40, secure=False, filepath=None, filename=None, folder_path=None):
        """Connects to neo4j database, loads options and set connectors.
        @raise CuckooReportError: if unable to connect."""
        self.threshold = int(threshold)
        #self.graph = Graph(host=host, user=user, password=password, secure=secure, port=port)
        self.filepath = filepath
        self.filename= filename
        self.folder_path = folder_path
        #self.scout = ApiScout()
        #self.scout.setBaseAddress(0)

        
        self.pe = None
        self.angr = None

        self.magictest = magic.Magic(uncompress=True)
        self.signatures = None

        CWD = os.path.abspath(os.path.dirname(__file__))
        USERDB = os.path.join(CWD, os.path.normpath("data/MalScan.txt"))
        #with open(USERDB, 'rt') as f:
            #sig_data = f.read()
            #self.signatures = peutils.SignatureDatabase(sig_data)


    def _get_exports(self):
        """Get file imports.
        @return: Return imports as list or None
        """


    def _create_angr_files(self):
        """Send a call to another script.
        @return: another terminal with script
        """
        subprocess.call(["gnome-terminal", "-x", "sh", "-c", "python3 script.py " + self.filepath +"; bash"])

    def run(self):
        if not os.path.exists(self.filepath):
            return None
        
        try:
            self.pe = pefile.PE(self.filepath, fast_load=True)
            self.pe.full_load()
        except pefile.PEFormatError:
            return None

        results = {}
        results["peid_signatures"] = Pefile(self.filepath)._get_peid_signatures()
        results["pe_imports"] = Pefile(self.filepath)._get_imported_symbols()
        

        #Do work
        Pefile(self.filepath)._create_pe_files()
        self._create_angr_files()

        return results

#Api(threshold=40, host="me", port=4449, user="VipeL", password="Lukas...", filepath="../../requirements.txt", filename='requirements.txt', folder_path="../../", secure=False,).get_signatures()

class Static():
    """Static analysis"""

    def __init__(self, filepath):
        self.filepath = filepath

    def run(self):
        """Run analysis.
        @return: result dict.
        """

        #if self.task["category"] == "file"::
        #Api(self.n4j_host,self.n4j_port,self.n4j_user,self.n4j_password,self.threshold)
        static = Api("admin" ,8001, "devlogin", "admin", 40, False, self.filepath).run()

        return static
