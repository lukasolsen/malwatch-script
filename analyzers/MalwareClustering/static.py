#!/usr/bin/env python
# -*- coding: utf-8 -*-

import os
import json
import requests
import hashlib
import glob
from clib.malwatch.common.constants import MALWATCH_ROOT
from clib.malwatch.local_settings import ROOT_DESTINATION
import magic
from modules.utilities import createFolder, isRunningInLinux, isRunningInWindows
import subprocess


try:
    import pefile
    import peutils
except ImportError:
    print ('pefile not installed, see http://code.google.com/p/pefile/')
    exit()

try:
    import angr
    import monkeyhex
except ImportError:
    print ("Angr is not installed correctly, see https://docs.angr.io/introductory-errata/install")
    pass

try:
    from lib.cuckoo.common.abstracts import Processing
    from lib.cuckoo.common.constants import CUCKOO_ROOT
    from lib.cuckoo.common.objects import File
    from lib.cuckoo.common.utils import convert_to_printable
except ImportError:
    print("Cuckoo is not installed, see http://cuckoo.readthedocs.io/en/latest/installation/")


import sys
import fnmatch
#import pyimpfuzzy

try:
    import re2 as re
except:
    import re

#from py2neo import Graph
#from pylouvain import PyLouvain
#from apiscout.ApiScout import ApiScout

statement_c = """
    MERGE (m:Malware{ id:{id} })"""

class Api():
    """Stores and analyze malwares info in neo4j"""

    def __init__(self, host, port, user, password, threshold=40, secure=False, filepath=None, filename=None, folder_path=None):
        """Connects to neo4j database, loads options and set connectors.
        @raise CuckooReportError: if unable to connect."""
        self.threshold = int(threshold)
        #self.graph = Graph(host=host, user=user, password=password, secure=secure, port=port)
        self.filepath = filepath
        self.filename= filename
        self.folder_path = folder_path
        #self.scout = ApiScout()
        #self.scout.setBaseAddress(0)

        
        self.pe = None
        self.angr = None

        self.magictest = magic.Magic(uncompress=True)
        self.signatures = None

        CWD = os.path.abspath(os.path.dirname(__file__))
        USERDB = os.path.join(CWD, os.path.normpath("data/MalScan.txt"))
        #with open(USERDB, 'rt') as f:
            #sig_data = f.read()
            #self.signatures = peutils.SignatureDatabase(sig_data)
    def check_file(self, f):
        if magic.from_file(f).find("PE32") == -1:
            return False
        if magic.from_file(f).find('self-extracting') != -1:
            return False
        try:
            pe = pefile.PE(f)
            #print(pe)
            matches = self.signatures.match_all(pe, ep_only = True)
            if matches:
                return False
            return True
        except:
            return False
    
    def _get_peid_signatures(self):
        """Gets PEID Signatures.
        @return: matched signatures or None.
        """
        if not self.pe:
            return None
        
        try:
            sig_path = os.path.join(CUCKOO_ROOT, "data",
            "signatures", "MalScan.TXT")
            signatures = peutils.SignatureDatabase(sig_path)
            return signatures.match(self.pe, ep_only=True)
        except:
            return None

    def _get_imported_symbols(self):
        """Gets imported symbols.
        @return: imported symbols dict or None.
        """

        if not self.pe:
            return None
        
        imports = []

        if hasattr(self.pe, "DIRECTORY_ENTRY_IMPORT"):
            for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
                try:
                    symbols = []
                    for imported_symbol in entry.imports:
                        symbol = {}
                        symbol["address"] = hex(imported_symbol.address)
                        symbol["name"] = imported_symbol.name
                        symbols.append(symbol)
                    
                    imports_section = {}
                    imports_section["dll"] = convert_to_printable(entry.dll)
                    imports_section["imports"] = symbols
                    imports.append(imports_section)
                except:
                    continue
        return imports

    def _create_pe_files(self):
        if not self.pe:
            return None

        createFolder(ROOT_DESTINATION, "PEFile-Reports")
        f = open(MALWATCH_ROOT + "/submissions/" + "PEFile-Reports/pefile.txt", 'w+')
        f.write(str(self.pe))
        f.close()

    def _create_angr_files(self):
        subprocess.call()




    def run(self):
        if not os.path.exists(self.filepath):
            return None
        
        try:
            self.pe = pefile.PE(self.filepath)
        except pefile.PEFormatError:
            return None

        results = {}
        results["peid_signatures"] = self._get_peid_signatures()
        results["pe_imports"] = self._get_imported_symbols()
        

        #Do work
        self._create_pe_files()

        return results

#Api(threshold=40, host="me", port=4449, user="VipeL", password="Lukas...", filepath="../../requirements.txt", filename='requirements.txt', folder_path="../../", secure=False,).get_signatures()

class Static():
    """Static analysis"""

    def __init__(self, filepath):
        self.filepath = filepath

    def run(self):
        """Run analysis.
        @return: result dict.
        """

        #if self.task["category"] == "file"::
        #Api(self.n4j_host,self.n4j_port,self.n4j_user,self.n4j_password,self.threshold)
        static = Api("admin" ,8001, "devlogin", "admin", 40, False, self.filepath).run()

        return static
